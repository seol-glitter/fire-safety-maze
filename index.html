<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>화재 대피 미로 게임</title>
<style>
  body { margin:0; background:#000; }
  #container { position:relative; width:100vw; height:100vh; overflow:hidden; }
  #gameCanvas { display:block; width:100%; height:100%; }
  #player, #exit {
    position:absolute;
    background-size:contain;
    background-repeat:no-repeat;
    transform:translate(-50%, -50%);
    z-index:10;
  }
  #player { width:10%; height:10%; background-image:url("running.png"); }
  #exit   { width:12%; height:12%; background-image:url("exit.png"); }
</style>
</head>
<body>
<div id="container">
  <canvas id="gameCanvas"></canvas>
  <div id="player"></div>
  <div id="exit"></div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const mazeImg = new Image();
mazeImg.src = "maze.jpg";

const player = document.getElementById("player");
const exit = document.getElementById("exit");

let dragging = false;
let xRatio = 0.05, yRatio = 0.08; // 시작 위치 (비율로)
let exitXRatio = 0.9, exitYRatio = 0.9; // 출구 위치 (비율로)

// 화면에 맞게 캔버스 리사이즈
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  ctx.drawImage(mazeImg, 0, 0, canvas.width, canvas.height);
  updatePositions();
}

// 플레이어/출구 좌표 갱신
function updatePositions() {
  const rect = canvas.getBoundingClientRect();
  const px = xRatio * canvas.width;
  const py = yRatio * canvas.height;
  player.style.left = rect.left + px + "px";
  player.style.top  = rect.top  + py + "px";

  const ex = exitXRatio * canvas.width;
  const ey = exitYRatio * canvas.height;
  exit.style.left = rect.left + ex + "px";
  exit.style.top  = rect.top  + ey + "px";
}

// 이동 가능 여부 (흰색 길만 통과)
function canMove(newX, newY) {
  const cx = newX + player.offsetWidth/2;
  const cy = newY + player.offsetHeight/2;
  const pixel = ctx.getImageData(cx, cy, 1, 1).data;
  return (pixel[0] > 240 && pixel[1] > 240 && pixel[2] > 240);
}

// 플레이어 이동
function movePlayer(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const newX = clientX - rect.left - player.offsetWidth/2;
  const newY = clientY - rect.top  - player.offsetHeight/2;

  if (newX >= 0 && newY >= 0 &&
      newX <= canvas.width - player.offsetWidth &&
      newY <= canvas.height - player.offsetHeight) {
    if (canMove(newX, newY)) {
      xRatio = (newX + player.offsetWidth/2) / canvas.width;
      yRatio = (newY + player.offsetHeight/2) / canvas.height;
      updatePositions();

      // 출구 도착 확인
      const pRect = player.getBoundingClientRect();
      const eRect = exit.getBoundingClientRect();
      if (!(pRect.right < eRect.left || pRect.left > eRect.right ||
            pRect.bottom < eRect.top || pRect.top > eRect.bottom)) {
        alert("성공! 안전하게 도착했어요!");
      }
    }
  }
}

// 이벤트 등록
player.addEventListener("mousedown", ()=> dragging=true);
document.addEventListener("mousemove", e=>{ if(dragging) movePlayer(e.clientX, e.clientY); });
document.addEventListener("mouseup", ()=> dragging=false);

player.addEventListener("touchstart", ()=> dragging=true);
document.addEventListener("touchmove", e=>{ if(dragging) movePlayer(e.touches[0].clientX, e.touches[0].clientY); });
document.addEventListener("touchend", ()=> dragging=false);

mazeImg.onload = resizeCanvas;
window.addEventListener("resize", resizeCanvas);
</script>
</body>
</html>
