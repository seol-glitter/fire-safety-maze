<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>화재 대피 미로 게임</title>
<style>
  body { margin:0; background:#000; }
  #container { position:relative; width:100vw; height:100vh; overflow:hidden; }
  #gameCanvas { display:block; width:100%; height:100%; }
  #player, #exit {
    position:absolute;
    background-size:contain;
    background-repeat:no-repeat;
    transform:translate(-50%, -50%);
    z-index:10;
    pointer-events:auto;
  }
  /* running은 1.8배 확대 유지 */
  #player { width:10.8%; height:auto; aspect-ratio:1/1; background-image:url("running.png"); }
  /* exit은 원래 비율(8%) */
  #exit   { width:8%; height:auto; aspect-ratio:1/1; background-image:url("exit.png"); }
</style>
</head>
<body>
<div id="container">
  <canvas id="gameCanvas"></canvas>
  <div id="player"></div>
  <div id="exit"></div>
</div>

<script>
/* 요소 */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d", { willReadFrequently: true });
const mazeImg = new Image();
mazeImg.src = "maze.jpg";

const player = document.getElementById("player");
const exit   = document.getElementById("exit");

/* 상태 */
let dragging = false;
let gameOver = false;

/* 시작/출구 위치를 비율로 명확히 고정 */
const START_XR = 0.05, START_YR = 0.08;  // 시작 지점(비율)
const EXIT_XR  = 0.90, EXIT_YR  = 0.90;  // 출구 지점(비율)

/* 현재 위치(비율) */
let xRatio = START_XR, yRatio = START_YR;
let exitXRatio = EXIT_XR, exitYRatio = EXIT_YR;

/* 캔버스 리사이즈 및 배경 그리기 */
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  if (mazeImg.complete) {
    ctx.drawImage(mazeImg, 0, 0, canvas.width, canvas.height);
  }
  updatePositions();
}

/* 플레이어/출구 DOM 위치 갱신 */
function updatePositions() {
  const rect = canvas.getBoundingClientRect();
  const px = xRatio * canvas.width;
  const py = yRatio * canvas.height;
  player.style.left = rect.left + px + "px";
  player.style.top  = rect.top  + py + "px";

  const ex = exitXRatio * canvas.width;
  const ey = exitYRatio * canvas.height;
  exit.style.left = rect.left + ex + "px";
  exit.style.top  = rect.top  + ey + "px";
}

/* 해당 좌표가 흰색(길)인지 검사 */
function canMove(checkX, checkY) {
  const cx = checkX + player.offsetWidth / 2;
  const cy = checkY + player.offsetHeight / 2;
  if (cx < 0 || cy < 0 || cx >= canvas.width || cy >= canvas.height) return false;
  const pixel = ctx.getImageData(cx, cy, 1, 1).data;
  return (pixel[0] > 240 && pixel[1] > 240 && pixel[2] > 240); // 하얀 길만 통과
}

/* 경로를 여러 단계로 나눠 검사(안티-터널링) */
function movePlayer(clientX, clientY) {
  if (gameOver) return; // 종료 상태면 더 이상 이동 금지

  const rect = canvas.getBoundingClientRect();
  const targetX = clientX - rect.left - player.offsetWidth / 2;
  const targetY = clientY - rect.top  - player.offsetHeight / 2;

  const startX = xRatio * canvas.width - player.offsetWidth / 2;
  const startY = yRatio * canvas.height - player.offsetHeight / 2;

  const steps = 35; // 더 촘촘하게(통과 방지 강화)
  const dx = (targetX - startX) / steps;
  const dy = (targetY - startY) / steps;

  let newX = startX;
  let newY = startY;

  for (let i = 0; i <= steps; i++) {
    if (!canMove(newX, newY)) {
      // 벽 만나면 그 직전 위치로 유지하고 종료
      return;
    }
    newX += dx;
    newY += dy;
  }

  // 최종 목표지점 도달 가능
  xRatio = (targetX + player.offsetWidth / 2) / canvas.width;
  yRatio = (targetY + player.offsetHeight / 2) / canvas.height;
  updatePositions();

  // 출구 도착 체크 (한 번만)
  const pRect = player.getBoundingClientRect();
  const eRect = exit.getBoundingClientRect();
  const hit = !(pRect.right < eRect.left || pRect.left > eRect.right ||
                pRect.bottom < eRect.top || pRect.top > eRect.bottom);
 
 if (hit && !gameOver) {
  gameOver = true;
  alert("성공! 안전하게 도착했어요!");

  if (confirm("다시 시작할까요?")) {
    // ▶ 예: 게임만 리셋
    gameOver = false;
    xRatio = START_XR;
    yRatio = START_YR;
    updatePositions();

    // (선택) 주소에서 이전 해시/신호 제거
    try { history.replaceState(null, '', location.pathname + location.search); } catch(e){}
  } else {
    // ▶ 아니오: 성공 전용 페이지로 실제 이동(업무규칙이 이 URL을 감지)
    const base = 'https://seol-glitter.github.io/fire-safety-maze/cleared.html';
    const qs   = location.search || ''; // 기존 쿼리를 그대로 전달하고 싶을 때
    const sep  = qs ? '&' : '?';
    // 캐시 무효화를 위해 버전 파라미터 추가
    location.href = base + qs + sep + 'v=' + Date.now();
  }
}

/* 게임 재시작(페이지 새로고침 없이 상태만 리셋) */
function restartGame() {
  gameOver = false;
  xRatio = START_XR;
  yRatio = START_YR;
  updatePositions();
}

/* 이벤트 등록 */
player.addEventListener("mousedown", () => { if (!gameOver) dragging = true; });
document.addEventListener("mousemove", e => { if (dragging && !gameOver) movePlayer(e.clientX, e.clientY); });
document.addEventListener("mouseup",   () => dragging = false);

player.addEventListener("touchstart", () => { if (!gameOver) dragging = true; }, {passive:true});
document.addEventListener("touchmove", e => {
  if (dragging && !gameOver) movePlayer(e.touches[0].clientX, e.touches[0].clientY);
}, {passive:true});
document.addEventListener("touchend",  () => dragging = false);

/* 초기화 */
mazeImg.onload = resizeCanvas;
window.addEventListener("resize", resizeCanvas);
</script>
</body>
</html>
