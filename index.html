<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>화재 대피 미로 게임</title>
<style>
  body { margin:0; background:#000; }
  #container { position:relative; width:100vw; height:100vh; overflow:hidden; }
  #gameCanvas { display:block; width:100%; height:100%; }
  #player, #exit {
    position:absolute;
    background-size:contain;
    background-repeat:no-repeat;
    transform:translate(-50%, -50%);
    z-index:10;
  }
  /* 크기 1.8배 확대 */
  #player { width:10.8%; height:10.8%; background-image:url("running.png"); }
  #exit   { width:14.4%; height:14.4%; background-image:url("exit.png"); }
</style>
</head>
<body>
<div id="container">
  <canvas id="gameCanvas"></canvas>
  <div id="player"></div>
  <div id="exit"></div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const mazeImg = new Image();
mazeImg.src = "maze.jpg";

const player = document.getElementById("player");
const exit = document.getElementById("exit");

let dragging = false;
let xRatio = 0.05, yRatio = 0.08;       // 시작 위치 (비율 기준)
let exitXRatio = 0.9, exitYRatio = 0.9; // 출구 위치 (비율 기준)

// 캔버스 리사이즈 및 배경 그리기
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  ctx.drawImage(mazeImg, 0, 0, canvas.width, canvas.height);
  updatePositions();
}

function updatePositions() {
  const rect = canvas.getBoundingClientRect();
  const px = xRatio * canvas.width;
  const py = yRatio * canvas.height;
  player.style.left = rect.left + px + "px";
  player.style.top  = rect.top  + py + "px";

  const ex = exitXRatio * canvas.width;
  const ey = exitYRatio * canvas.height;
  exit.style.left = rect.left + ex + "px";
  exit.style.top  = rect.top  + ey + "px";
}

function canMove(checkX, checkY) {
  const pixel = ctx.getImageData(checkX + player.offsetWidth/2, checkY + player.offsetHeight/2, 1, 1).data;
  return (pixel[0] > 240 && pixel[1] > 240 && pixel[2] > 240); // 흰색만 통과
}

// 경로를 여러 단계로 나눠 검사
function movePlayer(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const targetX = clientX - rect.left - player.offsetWidth/2;
  const targetY = clientY - rect.top  - player.offsetHeight/2;

  const startX = xRatio * canvas.width - player.offsetWidth/2;
  const startY = yRatio * canvas.height - player.offsetHeight/2;

  const steps = 25; // 경로를 25단계로 나눔
  const dx = (targetX - startX) / steps;
  const dy = (targetY - startY) / steps;

  let newX = startX;
  let newY = startY;
  let canGo = true;

  for (let i = 0; i <= steps; i++) {
    if (!canMove(newX, newY)) {
      canGo = false;
      break;
    }
    newX += dx;
    newY += dy;
  }

  if (canGo) {
    xRatio = (targetX + player.offsetWidth/2) / canvas.width;
    yRatio = (targetY + player.offsetHeight/2) / canvas.height;
    updatePositions();

    // 출구 도착 체크
    const pRect = player.getBoundingClientRect();
    const eRect = exit.getBoundingClientRect();
    if (!(pRect.right < eRect.left || pRect.left > eRect.right ||
          pRect.bottom < eRect.top || pRect.top > eRect.bottom)) {
      alert("성공! 안전하게 도착했어요!");
    }
  }
}

// 이벤트 등록
player.addEventListener("mousedown", ()=> dragging=true);
document.addEventListener("mousemove", e=>{ if(dragging) movePlayer(e.clientX, e.clientY); });
document.addEventListener("mouseup", ()=> dragging=false);

player.addEventListener("touchstart", ()=> dragging=true);
document.addEventListener("touchmove", e=>{ if(dragging) movePlayer(e.touches[0].clientX, e.touches[0].clientY); });
document.addEventListener("touchend", ()=> dragging=false);

mazeImg.onload = resizeCanvas;
window.addEventListener("resize", resizeCanvas);
</script>
</body>
</html>
