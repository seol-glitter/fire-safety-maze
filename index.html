<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>화재 대피 미로 게임</title>
<style>
  :root{
    /* 미로 원본 비율: 902 x 487 */
    --maze-w: 902;
    --maze-h: 487;
    --aspect: calc(var(--maze-w) / var(--maze-h));
  }
  html, body { height:100%; }
  body { margin:0; background:#000; display:flex; justify-content:center; align-items:center; overflow:hidden; }

  /* 가로(랜드스케이프) 고정 느낌: 컨테이너는 가로에 맞춰 최대 크기로, 비율 유지 */
  #stage-wrap{
    position:relative;
    width:100vw;                  /* 우선 가로 꽉 채우기 */
    height:calc(100vw / var(--aspect)); /* 비율대로 높이 계산 */
    max-height:100vh;             /* 화면보다 크지 않게 */
    max-width:calc(100vh * var(--aspect)); /* 세로가 더 짧다면 그에 맞춰 가로 제한 */
    background:#000;              /* 레터박스 */
    display:flex; justify-content:center; align-items:center;
  }

  /* 실제 게임 영역(고정비 컨테이너) */
  #container{
    position:relative;
    width:100%; height:100%;
    overflow:hidden;
    touch-action:none; /* 브라우저 기본 스크롤/줌 방지 */
    background:#000;
  }

  /* 캔버스는 container를 딱 맞게 채우고, 내부 픽셀 크기도 JS에서 동일하게 설정 */
  #gameCanvas{ display:block; width:100%; height:100%; }

  /* 플레이어 및 출구는 container 좌표계 기준으로 배치(뷰포트X) */
  #player, #exit{
    position:absolute;
    transform:translate(-50%, -50%);
    background-size:contain;
    background-repeat:no-repeat;
    z-index:10;
    pointer-events:auto;
  }
  /* 요청대로 1.8배 확대된 느낌 유지(컨테이너 폭 기준 %) */
  #player{ width:10.8%; height:auto; aspect-ratio:1/1; background-image:url("running.png"); }
  #exit  { width:14.4%; height:auto; aspect-ratio:1/1; background-image:url("exit.png"); }

  /* 세로(포트레이트)에서는 회전 안내 오버레이 */
  #rotate-overlay{
    position:fixed; inset:0; background:#000; color:#fff;
    display:none; align-items:center; justify-content:center; text-align:center; padding:24px; z-index:9999;
  }
  #rotate-overlay.show{ display:flex; }
</style>
</head>
<body>
  <div id="rotate-overlay">가로 모드로 기기를 돌려 주세요.<br/>Landscape 모드에서 가장 잘 보여요.</div>

  <div id="stage-wrap">
    <div id="container">
      <canvas id="gameCanvas"></canvas>
      <div id="player"></div>
      <div id="exit"></div>
    </div>
  </div>

<script>
/** 요소 참조 */
const stageWrap = document.getElementById('stage-wrap');
const container = document.getElementById('container');
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently:true }); // 픽셀 읽기 성능 향상
const mazeImg = new Image();
mazeImg.src = 'maze.jpg';

const playerEl = document.getElementById('player');
const exitEl   = document.getElementById('exit');
const rotateOverlay = document.getElementById('rotate-overlay');

/** 내부 상태 (컨테이너 좌표계, px 단위) */
let cw = 0, ch = 0;          // container(width/height)
let dragging = false;

/* 시작/출구를 비율(0~1)로 명확히 고정해 두면, 어떤 화면에서도 같은 지점 */
let startXR = 0.05, startYR = 0.08;   // 시작점(좌상단 흰 길의 한 지점으로 조정)
let exitXR  = 0.90, exitYR  = 0.90;   // 출구(우하단 흰 길의 한 지점으로 조정)

/* 현재 플레이어 위치(컨테이너 px) */
let px = 0, py = 0;

/* 드래그 목적지 버퍼(컨테이너 px). 프레임마다 조금씩 이동하며 충돌 체크(안티터널링) */
let targetPX = 0, targetPY = 0;

/** 포트레이트(세로)면 안내 오버레이 */
function updateOrientationOverlay(){
  const isPortrait = window.innerHeight > window.innerWidth;
  rotateOverlay.classList.toggle('show', isPortrait);
}

/** 레이아웃 계산: stageWrap가 비율을 유지하므로 container 크기는 고정됨 */
function layout(){
  updateOrientationOverlay();

  // container 실제 렌더 크기
  cw = container.clientWidth;
  ch = container.clientHeight;

  // 캔버스 내부 픽셀 크기를 container 렌더 크기와 동일하게 맞춤 → 좌표계=화면계
  canvas.width  = cw;
  canvas.height = ch;

  // 배경(미로) 이미지를 현재 크기에 맞춰 다시 그림
  if (mazeImg.complete) {
    ctx.drawImage(mazeImg, 0, 0, cw, ch);
  }

  // 플레이어/출구 위치를 현재 비율 좌표에서 px로 갱신
  px = startXR * cw;
  py = startYR * ch;

  targetPX = px;
  targetPY = py;

  placePlayer(px, py);
  placeExit(exitXR * cw, exitYR * ch);
}

/** 요소 배치(컨테이너 좌표계) */
function placePlayer(x, y){
  playerEl.style.left = `${x}px`;
  playerEl.style.top  = `${y}px`;
}
function placeExit(x, y){
  exitEl.style.left = `${x}px`;
  exitEl.style.top  = `${y}px`;
}

/** 현재 중심 픽셀이 흰색(길)인지 검사 */
function isWhiteAt(cx, cy){
  // 경계 밖이면 false
  if (cx < 0 || cy < 0 || cx >= cw || cy >= ch) return false;
  const d = ctx.getImageData(cx, cy, 1, 1).data;
  return (d[0] > 240 && d[1] > 240 && d[2] > 240); // 하얀색 길만 통과
}

/** 플레이어 중심 좌표 계산(컨테이너 px) */
function getPlayerCenterAt(x, y){
  const rect = playerEl.getBoundingClientRect();
  const cRect = container.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;
  // x,y는 transform(-50%,-50%) 기준으로 center 위치이므로 그대로 중심
  return { cx: x, cy: y, hw:w/2, hh:h/2 };
}

/** 지정 좌표가 유효(벽 아님)인지 */
function canStandAt(x, y){
  const { cx } = getPlayerCenterAt(x, y);
  const { cy } = getPlayerCenterAt(x, y);
  return isWhiteAt(cx, cy);
}

/** 안티-터널링: 작은 스텝으로만 이동 */
function stepTowardsTarget(){
  // 한 프레임당 이동 최대 거리(px)
  const STEP = Math.max(2, Math.min(cw, ch) * 0.006); // 화면 크기에 비례(약 0.6%)
  const dx = targetPX - px;
  const dy = targetPY - py;
  const dist = Math.hypot(dx, dy);
  if (dist < 0.5) return; // 충분히 도달

  // 한 스텝 진행
  const move = Math.min(STEP, dist);
  const nx = px + (dx / dist) * move;
  const ny = py + (dy / dist) * move;

  // 스텝을 더 잘게 나눠 중간 샘플도 체크(초정밀)
  const SUB = 4;
  let ok = true, tx = px, ty = py;
  for(let i=1;i<=SUB;i++){
    const ix = px + (dx / dist) * (move * i / SUB);
    const iy = py + (dy / dist) * (move * i / SUB);
    if (!canStandAt(ix, iy)) { ok = false; break; }
    tx = ix; ty = iy;
  }

  if (ok){
    px = tx; py = ty;
    placePlayer(px, py);
    checkExit();
  } else {
    // 벽이면 더 진행하지 않음(현재 위치 유지)
  }
}

/** 출구 도착 판정 */
function checkExit(){
  const p = playerEl.getBoundingClientRect();
  const e = exitEl.getBoundingClientRect();
  const hit = !(p.right < e.left || p.left > e.right || p.bottom < e.top || p.top > e.bottom);
  if (hit){
    alert('성공! 안전하게 도착했어요!');
  }
}

/** 드래그 입력을 컨테이너 좌표로 변환 */
function toContainerXY(clientX, clientY){
  const r = container.getBoundingClientRect();
  let x = clientX - r.left;
  let y = clientY - r.top;
  // 경계 클램프
  x = Math.max(0, Math.min(x, cw));
  y = Math.max(0, Math.min(y, ch));
  return {x, y};
}

/** 이벤트 */
playerEl.addEventListener('mousedown', ()=> dragging = true);
document.addEventListener('mousemove', (e)=>{
  if (!dragging) return;
  const {x, y} = toContainerXY(e.clientX, e.clientY);
  targetPX = x; targetPY = y;
});
document.addEventListener('mouseup', ()=> dragging = false);

playerEl.addEventListener('touchstart', ()=> dragging = true, {passive:true});
document.addEventListener('touchmove', (e)=>{
  if (!dragging) return;
  const t = e.touches[0];
  const {x, y} = toContainerXY(t.clientX, t.clientY);
  targetPX = x; targetPY = y;
}, {passive:true});
document.addEventListener('touchend', ()=> dragging = false);

/** 메인 루프: 프레임마다 조금씩 이동 → 벽 침투 방지 */
function loop(){
  stepTowardsTarget();
  requestAnimationFrame(loop);
}

/** 초기화 */
mazeImg.onload = ()=>{
  layout();     // 컨테이너/캔버스 사이즈 맞추고 그리기
  loop();       // 이동 루프 시작
};
window.addEventListener('resize', layout);
window.addEventListener('orientationchange', ()=>{
  setTimeout(layout, 300); // 회전 직후 키보드/주소창 애니메이션 안정화 대기
});
</script>
</body>
</html>
