<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>화재 대피 미로 게임</title>
<style>
  body { margin:0; display:flex; justify-content:center; align-items:center; background:#eee; height:100vh; }
  #container { position:relative; width:100%; height:100%; max-width:100vw; max-height:100vh; }
  #gameCanvas {
    width:100%;  /* 반응형 크기 */
    height:100%;
    display:block;
  }
  #player, #exit {
    position:absolute;
    background-size:contain;
    background-repeat:no-repeat;
    transform: translate(-50%, -50%); /* 좌표를 중심 기준으로 */
  }
  #player { width:6%; height:6%; background-image:url("running.png"); }
  #exit   { width:8%; height:8%; background-image:url("exit.png"); }
</style>
</head>
<body>
<div id="container">
  <canvas id="gameCanvas" width="902" height="487"></canvas>
  <div id="player"></div>
  <div id="exit"></div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const mazeImg = new Image();
mazeImg.src = "maze.jpg";

const player = document.getElementById("player");
const exit = document.getElementById("exit");

// 내부 좌표 (원본 902×487 기준)
let x = 50, y = 50;
let dragging = false, offsetX, offsetY;

mazeImg.onload = () => {
  ctx.drawImage(mazeImg, 0, 0, canvas.width, canvas.height);
  updatePlayerPosition();
  // 출구 위치: 우측 하단
  exit.style.left = (canvas.width - 70) + "px";
  exit.style.top  = (canvas.height - 70) + "px";
};

function updatePlayerPosition() {
  const rect = canvas.getBoundingClientRect();
  const scaleX = rect.width / canvas.width;
  const scaleY = rect.height / canvas.height;
  player.style.left = rect.left + x * scaleX + "px";
  player.style.top  = rect.top + y * scaleY + "px";
}

function canMove(newX, newY) {
  const cx = newX + 25; // 중심 좌표
  const cy = newY + 25;
  const pixel = ctx.getImageData(cx, cy, 1, 1).data;
  return (pixel[0] > 240 && pixel[1] > 240 && pixel[2] > 240); // 하얀색만 통과
}

function movePlayer(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const newX = (clientX - rect.left) * scaleX - 25;
  const newY = (clientY - rect.top) * scaleY - 25;
  
  if (canMove(newX, newY)) {
    x = newX; y = newY;
    updatePlayerPosition();

    // 출구 충돌 검사
    const pRect = player.getBoundingClientRect();
    const eRect = exit.getBoundingClientRect();
    if (!(pRect.right < eRect.left || pRect.left > eRect.right ||
          pRect.bottom < eRect.top || pRect.top > eRect.bottom)) {
      alert("성공! 안전하게 도착했어요!");
    }
  }
}

// 마우스
player.addEventListener("mousedown", e => { dragging = true; });
document.addEventListener("mousemove", e => { if(dragging) movePlayer(e.clientX, e.clientY); });
document.addEventListener("mouseup", () => dragging=false);

// 터치
player.addEventListener("touchstart", e => { dragging=true; });
document.addEventListener("touchmove", e => { if(dragging) movePlayer(e.touches[0].clientX, e.touches[0].clientY); });
document.addEventListener("touchend", () => dragging=false);

window.addEventListener("resize", updatePlayerPosition);
</script>
</body>
</html>
